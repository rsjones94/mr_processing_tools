!!ARBfp1.0
#
# Fragment program used for rendering GLVector instances, where
# the vector orientation is represented by a combination of RGB colours.
#
# This fragment program does the following:
# 
#  - Retrieves the voxel coordinates corresponding to the fragment
# 
#  - Uses those voxel coordinates to look up the corresponding xyz
#    directions value in the 3D RGB image texture.
#
#  - Looks up the colours corresponding to those xyz directions.
#
#  - Modulates those colours by the modulation texture.
#
#  - Uses those voxel values to colour the fragment.
#
# Input parameters:
#
#   voxValXform - Transformation matrix which transforms the vector
#                 image voxel values from their texture value
#                 to the original data range.
#
#   cmapXform   - Transformation matrix which transforms the vector
#                 image voxel values from their data values
#                 to a value which can be used as texture coordinates
#                 for the colour map textures.
#
#   imageShape  - Image shape - number of voxels along the xyz
#                 dimensions in the image
#
#   clipping    - Clipping thresholds. The (x) component contains
#                 the low clipping threshold, and the (y) component
#                 contains the high threshold.
#
#   mod         - Modulation range. The (x) component contains
#                 the low modulation value, the (y) component
#                 the high modulation value, and the (z) component
#                 contains a scaling factor equal to
#                 1 / (modHigh - modLow).
#
#   xColour     - Colour corresponding to the X vector direction.
#
#   yColour     - Colour corresponding to the Y vector direction.
#
#   zColour     - Colour corresponding to the Z vector direction.
#
#   colourXform - Scale/offset to be applied to the vector value before
#                 it is combined with the three colours, for brightness/
#                 contrast adjustment. The first component contains
#                 the scaling factor, and the second component contains
#                 the offset.
#
# Input textures:
#
#   vectorTexture   - 3D texture containing the vector data.
#   modulateTexture - 3D texture containing brightness modulation values.
#   clipTexture     - 3D texture containing clipping values.
#
# Input varyings:
# 
#   vecTexCoord  - Vector image texture coordinates
#   clipTexCoord - Clipping image texture coordinates
#   modTexCoord  - Modulate image texture coordinates
#   voxCoord     - Fragment voxel coordinates 
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

TEMP  voxCoord;
TEMP  clipValue;
TEMP  modValue;
TEMP  voxValue;
TEMP  fragColour;
TEMP  clipResult;
TEMP  clipValueNoClip;
TEMP  modValueNoMod;

TEMP  tb_texcoord;
TEMP  tb_origval;
TEMP  tb_borderval;
TEMP  tb_result;

PARAM voxValXform[4] = {{ param4_voxValXform    }};
PARAM cmapXform[4]   = {{ param4_cmapXform      }};
PARAM imageShape     = {{ param_imageShape      }};
PARAM clipping       = {{ param_clipping        }};
PARAM mod            = {{ param_mod             }};
PARAM xColour        = {{ param_xColour         }};
PARAM yColour        = {{ param_yColour         }};
PARAM zColour        = {{ param_zColour         }};
PARAM colourXform    = {{ param_colourXform     }};

# retrieve the voxel coordinates 
MOV voxCoord, {{ varying_voxCoord }};

# Bail if the voxel coordinate
# is out of the image space
#pragma include test_in_bounds.prog

# look up vector, modulation, and clipping
# values from the three 3D textures.
TEX voxValue,  {{ varying_vecTexCoord  }}, {{ texture_vectorTexture   }}, 3D;
TEX modValue,  {{ varying_modTexCoord  }}, {{ texture_modulateTexture }}, 3D;
TEX clipValue, {{ varying_clipTexCoord }}, {{ texture_clipTexture     }}, 3D;

# Clobber the clipping/modulation
# values we just looked up if their
# texture coords were out of bounds.

# clipValueNoClip contains clipLo + 0.5 * (clipHi - clipLo)
MOV clipValueNoClip.x, clipping.y;
SUB clipValueNoClip.x, clipValueNoClip.x, clipping.x;
MUL clipValueNoClip.x, clipValueNoClip.x, 0.5;
ADD clipValueNoClip.x, clipValueNoClip.x, clipping.x;

# modValueNoMod contains (modHigh - 2 * modLow) - 
# this cancels out the modValue scaling at the
# bottom, so it results in a mod value of 1.
MOV modValueNoMod.x, mod.x;
MUL modValueNoMod.x, modValueNoMod.x, -2;
ADD modValueNoMod.x, modValueNoMod.x, mod.y;

# Clobber clipValue
MOV tb_texcoord,  {{ varying_clipTexCoord }};
MOV tb_origval.x,   clipValue.x;
MOV tb_borderval.x, clipValueNoClip.x;
#pragma include texture_border.prog
MOV clipValue.x, tb_result.x;

# Clobber modValue
MOV tb_texcoord,  {{ varying_modTexCoord }};
MOV tb_origval.x,   modValue.x;
MOV tb_borderval.x, modValueNoMod.x;
#pragma include texture_border.prog
MOV modValue.x, tb_result.x;

# If the clipping value is
# <= the low clipping range,
# or >= the high clipping
# range, kill the fragment.
SUB clipResult.x, clipValue.x, clipping.x;
SUB clipResult.y, clipping.y,  clipValue.x;

# Set the clipResults which are less than or
# equal to zero to negative 1. See comment
# about this in glvolume_frag.prog.
MUL clipResult, clipResult, -1.0;
SGE clipResult, clipResult,  0.0;
MUL clipResult, clipResult, -1.0;

KIL clipResult.x;
KIL clipResult.y;

# Transform vector values from their normalised 
# texture range to their original data range,
# and take the absolue value
MAD voxValue, voxValue, voxValXform[0].x, voxValXform[3].x;
ABS voxValue, voxValue;

# Cumulatively combine the rgb
# channels of those three colours
MOV fragColour, 0;
MAD fragColour, voxValue.x, xColour, fragColour;
MAD fragColour, voxValue.y, yColour, fragColour;
MAD fragColour, voxValue.z, zColour, fragColour;

# Copy the alpha value - we don't 
# want it to be modulated. Using
# voxValue as a temp variable
MOV voxValue.a, fragColour.a;

# Apply the bri/con scale and offset
MAD fragColour, fragColour, colourXform.x, colourXform.y;

# Scale the modulation value, modulate 
# the colour, and restore the alpha value.
ADD modValue.x, modValue.x, mod.x;
MUL modValue.x, modValue.x, mod.z;
MUL fragColour, fragColour, modValue.x;
MOV fragColour.a, voxValue.a;

# Colour the pixel!
MOV result.color, fragColour;

END

